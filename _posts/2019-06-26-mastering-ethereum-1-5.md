---
title: "마스터링 이더리움 1장~5장"
categories:
  -  Ethereum
tags:
  - Ethereum
  - Blockchian
comments: true
---

# 1장. 이더리움이란 무엇인가?
## 이더리움?

>"스마트 컨트랙트라는 프로그램을 실행하는 오픈 소스에 기반을 둔, 전 세계에 걸쳐 탈중앙화된 컴퓨팅 인프라스트럭처다."

- Blockchain Computer
- **World Computer**
	- Globally Accesible singleton state and virtual machine
- State Machine
- Decentralized Computer
- Platform
	- for developer
	- smart contract
	- decentralized application (DApp)
 
## 비트코인 vs 이더리움
### 공통점 
- P2P
- Byzantine fault-tolerant consensus
- 디지털 서명과 해쉬
- 디지털 화폐
### 차이점
| |비트코인|이더리움|
|---|---|---|
|목적|디지털 화폐 지급 네트워크|유틸리티 화폐|
|컨셉|디지털 화폐|스마트 컨트랙트|
|설계|스크립트 언어|가상 머신 운영(범용 프로그래밍)|
|언어|지불 조건에 대한 단순한 참/거짓 평가에 제한|튜링 완전 언어|
|트랜잭션|send from alice to bob|send from alice to bob if... (date=jan 1,2018, bob's balance < 10eth)|

# 2장. 이더리움 기초
## 이더 화폐 단위 
- 이더(ether): 기본 단위
- 웨이(wei): 가장 작은 단위 
	- $1 \ ETH = 1 * 10^{18} \ wei$ (100경(quintillion)
- 이더의 가치는 항상 이더리움 내부에서 웨이로 표시된 부호 없는 정숫값으로 표현됨
	- 1이더를 거래할 때, 그 트랜잭션은 1000000000000000000웨이 값으로 인코딩해서 표기
	
## 월드 컴퓨터
### EVM(Ethereum Virtual Machine, EVM)
- 글로벌 싱글톤
	- 전 세계에 걸친 단일 인스턴스 컴퓨터처럼 작동
	- 세상 어디에서든 실행
- 이더리움 네트워크의 각 노드는 컨트랙트 실행을 확인하기 위해 EVM의 로컬 사본을 실행하고, 이더리움 블록체인은 트랜잭션과 스마트 컨트랙트를 처리할 때 월드 컴퓨터의 변화하는 상태를 기록한다

## 외부 소유 계정(EOA, Externally Owned Account) 및 컨트랙트(contract account)
| |EOA|컨트랙트|
|---|:-:|:-:|
|개인키 유무|O|X|
|스마트 컨트랙트 코드|X|O|
|역할|자금 또는 컨트랙트에 대한 접근 제어|스마트 컨트랙트의 로직으로 제어|
|트랜잭션 시작|가능(개인키 있으므로)|불가능(개인키 없으므로)|

- 스마트 컨트랙트 코드: 컨트랙트 계정 생성 시 이더리움 블록체인에 기록되고 EVM에 의해 실행되는 소프트웨어 프로그램
- 컨트랙트에는 EOA와 마찬가지로 주소가 있으며, 이더를 보내고 받을 수 있다
- 트랜잭션 목적지가 컨트랙트 주소일 때, 트랜잭션과 트랜잭션 데이터를 입력으로 사용하여 컨트랙트가 EVM에서 실행된다(run)
- 컨트랙트는 블록체인에 바이트코드를 등록하는 특별한 트랜잭션에 의해 생성됨
- 컨트랙트가 블록체인에서 생성되면 지갑과 마찬가지로 이더리움 주소를 갖게됨
- 누군가 컨트랙트 주소로 트랜잭션을 보낼 때마다 그 트랜잭션에는 이더, 데이터 또는 둘다 포함할 수 있다.
	- 트랜잭션이 이더를 포함하면 커트랙트 잔액에 **예치된다**
	- 데이터가 포함되면 데이터에서는 컨트랙트에 명명된 함수를 지정하고 호출(call)하여 함수에 인수를 전달할 수 있다
- 컨트랙트 계정은 트랜잭션을 실행할 수 없지만, 복잡한 실행 경로를 구축하여 다른 컨트랙트를 호출해서 컨트랙트에 반응(react)할 수 있다.
	- 예: 다중 서명 스마트 트랜잭션 지갑에 지급요청 트랜잭션을 전송하여 일부 ETH를 다른 주소로 보낼 수 있음
		- 일반적인 DApp 프로그래밍 패턴은 컨트랙트 A가 컨트랙트 B를 호출하게 하는 것인데, 이렇게 하면 컨트랙트 A의 사용자들 간에 공유된 상태를 유지할 수 있게 됨

# 3장. 이더리움 클라이언트
## 클라이언트
- Parity, written in Rust
- Geth, written in Go
- cpp-ethereum, written in C++
- py-evm, written in Python
- Mantis, written in Scala
- Harmony, written in Java

# 4장. 암호학
## 공개키 암호화
- 이전 자료 대체
- 
## 이더리움 주소
> Keccak-256 단방향 해시 함수를 사용하는 공개키 또는 컨트랙트에서 파생한 고유 식별자(unique identifier)

private key k
```
k=f8f8a2f43c8376......
```
public key K(x, y 좌표가 연결되고 16진수로 표현됨)
```
K=6e145ccef...
```
Keccak-256을 사용해서 공개키의 해시를 계산
```
Keccak256(K)=2a5bc342....
```
마지막 20바이트(최하위 바이트)만 이더리움 주소로 사용
```
001d3flef827552ae1114027bd3ecf1f086a0f9
```
접두어 0x로 표시되어 16진수로 인코딩
```
0x001d3flef827552ae1114027bd3ecf1f086a0f9
```

# 5장. 지갑
> - 넓은 의미
> 이더리움 주요 사용자 인터페이스를 제공하는 소프트웨어 애플리케이션
> - 좁은 의미(개발자 시각)
> 사용자의 키를 보괂고 관리하기 위해 사용되는 시스템을 의미하며 모든 지갑은 키 관리 구성요소를 갖고 있다. (그 자체로 전부인 지갑, 브라우저 일부, DApp의 일부 등)

## 개요
### 지갑 설계 고려사항
편의성, 프라이버시 사이 균형 

||편리함|불편함|
|---|---|---|
|프라이버시 좋음|모든 트랜잭션에 새로운 키 사용|
|프라이버시 나쁨|하나의 개인키와 주소를 가지고 이를 재사용해서 모든 것을 처리||

## 지갑 형태
지갑이 포함하는 키가 서로 관련이 있느냐 없느냐에 따라 구분
### 1. 비결정적 지갑(nondeterministic wallet)
> JBOK(Just a Bunch Of Keys, 그냥 열쇠뭉치)
- 첫 번째 이더리움 지갑(이더리움 사전 판매용으로 생성)은 각 지갑 파일에 부작위로 추출된 단일 개인키를 저장함

### 2. 결정적 지갑(deterministic wallet)
> 모든 키가 seed라고 하는 단일 마스터 키로부터 파생
> 모든 키는 서로 관련이 있고 원래의 시드를 갖고 있다면 다시 키를 파생시킬 수 있다
> 여러 가지 키 파생(key derivation)방식이 있는데 가장 많이 사용하는 방식은 트리 같은 구조(**HD 지갑**)

#### HD지갑(